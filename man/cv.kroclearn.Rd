% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cv.kroclearn.R
\name{cv.kroclearn}
\alias{cv.kroclearn}
\title{Cross-validation for Kernel AUC Maximization Models}
\usage{
cv.kroclearn(
  X,
  y,
  lambda.vec = NULL,
  lambda.length = 50,
  kernel = "radial",
  param.kernel = NULL,
  loss = "hinge",
  approx = NULL,
  intercept = TRUE,
  nfolds = 10,
  target.perf = list(),
  param.convergence = list()
)
}
\arguments{
\item{X}{Predictor matrix or data.frame (categorical variables are
automatically one-hot encoded).}

\item{y}{Response vector with class labels in \{-1, 1\}. Labels given as
\{0,1\} or as a two-level factor/character are coerced automatically.}

\item{lambda.vec}{Optional numeric vector of penalty values. If \code{NULL},
a decreasing sequence is generated automatically.}

\item{lambda.length}{Number of \eqn{\lambda} values to generate if
\code{lambda.vec} is \code{NULL}.}

\item{kernel}{Kernel type: \code{"radial"}, \code{"polynomial"},
\code{"linear"}, or \code{"laplace"}.}

\item{param.kernel}{Kernel-specific parameter (e.g., \eqn{\sigma} for
radial/laplace kernels, polynomial degree).}

\item{loss}{Loss function: \code{"hinge"}, \code{"hinge2"} (squared hinge),
\code{"logistic"}, or \code{"exponential"}.}

\item{approx}{Logical; if \code{TRUE}, train the kernel model using
subsampled positive–negative pairs (incomplete U-statistic), and further
apply a Nyström approximation to the kernel matrix. This reduces memory and
time cost for large datasets. Default is \code{TRUE} when \code{nrow(X) >= 1000}.}

\item{intercept}{Logical; include an intercept in the model (default \code{TRUE}).}

\item{nfolds}{Number of cross-validation folds (default 10).}

\item{target.perf}{List of target performance criteria (passed to
\code{kroclearn}, e.g., sensitivity/specificity thresholds).}

\item{param.convergence}{List of convergence controls (e.g., \code{maxiter},
\code{eps}).}
}
\value{
An object of class \code{"cv.kroclearn"} with:
\itemize{
\item \code{optimal.lambda} — selected \eqn{\lambda}.
\item \code{optimal.fit} — model refit on the full data at
\code{optimal.lambda}.
\item \code{lambda.vec} — grid of penalty values considered.
\item \code{auc.mean}, \code{auc.sd} — mean and sd of cross-validated AUC.
\item \code{auc.result} — fold-by-lambda AUC matrix.
\item \code{time.mean}, \code{time.sd} — mean and sd of training time.
\item \code{time.result} — fold-by-lambda training time matrix.
\item \code{nfolds}, \code{loss}, \code{kernel} — settings.
}
}
\description{
Perform k-fold cross-validation over a sequence of \eqn{\lambda} values
and select the optimal kernel model based on cross-validated AUC.
}
\examples{
\dontrun{
## Kernel model example
set.seed(123)
n <- 1500
r <- sqrt(runif(n, 0.05, 1))
theta <- runif(n, 0, 2*pi)
X <- cbind(r * cos(theta), r * sin(theta))
y <- ifelse(r < 0.5, 1, -1)

cvfit <- cv.kroclearn(
  X, y,
  lambda.vec = exp(seq(log(0.01), log(5), length.out = 5)),
  kernel = "radial",
  nfolds = 5
)
cvfit$optimal.lambda
}
}
